* 1.1 Random Walks

The book begins by discussing how to implement Brownian motion through objects. We don't have objects in Clojure, so a central topic of this chapter's adaptation will be how to implement the same concepts in a functional way.

Shiffman writes: 

#+BEGIN_QUOTE
"An object in Processing is an entity that has both data and functionality. We are looking to design a
Walker object that both keeps track of its data (where it exists on the screen) and has the capability
to perform certain actions (such as draw itself or take a step)."
#+END_QUOTE

This is alien to functional programming. We instead will seek to write /functions/ which /update state/ and /render state/. 

#+BEGIN_SRC clojure

(def example_walker {:x 0 :y 0})


(def sketchWidth 500)
(def sketchHeight 500)
(def walker_start {:x (/ sketchWidth 2)
                   :y (/ sketchHeight 2)})

; side effects
(defn display_walker [w]
  (point (get w :x) (get w :y)) 
; we don't yet have the function (point x y) - it's a htdp-style wishlist!
)

(defn walker_update [w]
 (let c (rand-int 4)
  (cond
    (= c 0) {:x (+ 1 (get w :x)) :y (get w :y)}
    (= c 1) {:x (- 1 (get w :x)) :y (get w :y)}
    (= c 2) {:x (get w :x) :y (+ 1 (get w :y))}
    (= c 3) {:x (get w :x) :y (- 1 (get w :y))}
   )
  )
)

#+END_SRC

We really don't need more than this to keep track of how our walker is doing over time.

/there's probably some too-clever-by-half way of rewriting the update function to be shorter using polar coordinates (which might look pretty cool), but that would require some sampling to map between the polar coordinates and the discrete pixels of the canvas/

We can intuitively test the behavior of ~walker_update~ using the thread-first macro. Execute the block many times and see the result change each time:
#+BEGIN_SRC clojure
(-> example_walker
   walker_update
   walker_update
   walker_update
   walker_update
   walker_update
   walker_update
   walker_update)
#+END_SRC

#+RESULTS:


** Putting the walker together
When tangled, this code block will execute a self-contained version of the walker example.

#+BEGIN_SRC clojure :tangle ch1_walker_core.clj
(ns noc_ch1_walker.core
  (:require [quil.core :as q]
            [quil.middleware :as m]))

 (def width 1500) ; no magic numbers
 (def height 1500) 


(defn setup []; this function is called first when the sketch runs
  (q/color-mode :hsb) ; side effect 1: sketch mode
  (q/background 50) ; side effect 2: set the background color
  {:x (/ width 2) :y (/ height 2)} ; start at the center
  ; all state is encapsulated by a single walker
)

(defn display_walker [w]
  (q/fill 205)
  (q/no-stroke)
  (q/ellipse (get w :x) (get w :y) 3 3)
)

(defn draw [walker]

  (q/fill 205)
  (display_walker walker)
)

(defn walker_update [w]
 (let [c (rand-int 4)]
  (cond
    (= c 0) {:x (+ 1 (get w :x)) :y (get w :y)}
    (= c 1) {:x (- 1 (get w :x)) :y (get w :y)}
    (= c 2) {:x (get w :x) :y (+ 1 (get w :y))}
    (= c 3) {:x (get w :x) :y (- 1 (get w :y))}
   )
  )
)


(defn main [& args]
  (q/defsketch walker01
   :title "brownian motion"
   :size [width height]
   :setup setup
   :update walker_update
   :draw draw
   :middleware [m/fun-mode]
  )
)
#+END_SRC
